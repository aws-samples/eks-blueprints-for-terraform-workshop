---
title: "ApplicationSet"
weight: 40
---

<!-- cspell:disable-next-line -->

::video{id=3u0P46nxyVE}


Think of an ApplicationSet as a factory for ArgoCD Applications. It defines a template and uses generators to create multiple Application objects.

![Factory](/static/images/argobasics/factory-applicationset.png)

### 1. Why ApplicationSets Matter

ApplicationSets solve the **automation challenge** . Without them, deploying applications across multiple clusters becomes manual work that doesn't scale.

**The Problem**: Imagine you have 5 clusters and need to deploy a new microservice. You'd manually create 5 separate Application objects. When you add a new cluster, you'd manually create another Application. This manual process is error-prone and time-consuming.

**The Solution**: ApplicationSets automate this entirely. Define your deployment pattern once, and ApplicationSets automatically:

- Generate Applications for all matching clusters
- Handle new clusters automatically when they're added

In the previous chapter, you deployed an application using an ArgoCD Application object to the hub cluster.
To deploy the same application to another cluster( dev), you would need to create another ArgoCD Application manually.

![With ApplicationSet](/static/images/argobasics/without-applicationset.png)

Instead of doing that every time, Argo CD offers a more scalable and automated solution — the ApplicationSet.

![With ApplicationSet](/static/images/argobasics/with-applicationset.png)

Let’s create an ApplicationSet that deploys the guestbook ArgoCD Application to list of clusters. In this example to the hub cluster.

### 2. Create guestbook ApplicationSet

<!-- prettier-ignore-start -->
:::code{showCopyAction=true showLineNumbers=true language=json highlightLines='11,12,14,15,17,27'}
cd ~/environment/basics
cat <<'EOF' >> ~/environment/basics/guestbookApplicationSet.yaml
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: guestbook
  namespace: argocd
spec:
  goTemplate: true
  goTemplateOptions: ["missingkey=error"]
  generators:
  - list:
      elements:
      - name: hub
  template:
    metadata:
      name: '{{.name}}-guestbook'
      finalizers:
        - resources-finalizer.argocd.argoproj.io      
    spec:
      project: "default"
      source:
        repoURL: https://github.com/argoproj/argocd-example-apps.git
        path: guestbook
        targetRevision: HEAD
      destination:
        name: '{{.name}}'
        namespace: default
      syncPolicy:
        automated: {}        

EOF
kubectl apply -f ~/environment/basics/guestbookApplicationSet.yaml
:::
<!-- prettier-ignore-end -->

Key Components:

- Line 11: Start of generators section. This section creates parameters for the template section
- Line 12: There are many types of generators. We are using List generator
- Line 14: The list generator has one element
- Line 15: Template section. Applications are created with this template
- Line 17: Template using parameters generated by generators
- Line 27: Template using parameters generated by generators

### 3. Verify Application

Navigate to the ArgoCD web UI. You should see the guestbook ArgoCD Application listed.

![ArgoCD Application Guestbook](/static/images/argobasics//guestbook-ui.png)

### 4. Clean Up

<!-- prettier-ignore-start -->
:::code{showCopyAction=true showLineNumbers=false language=json}
kubectl delete -f ~/environment/basics/guestbookApplicationSet.yaml
:::
<!-- prettier-ignore-end -->

## Dynamic Generator

The previous example used a static list generator, which requires you to manually edit the ApplicationSet to add new values. This isn't truly automated.

ArgoCD supports dynamic generators that automatically discover and generate Applications based on changing conditions. ArgoCD supports different types of [generators](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators/) like cluster, git, matrix, and more to dynamically generate Applications

## Cluster Generator

Let's explore how the Cluster generator works. The Cluster generator selects clusters based on **labels** defined on the cluster object. You can view labels navigating to ArgoCD dashboard > Settings > Clusters > hub:

![Hub Cluster Labels](/static/images/argobasics/hubcluster-initial-labels.png)

We added label "cluster-role=hub" while registering hub cluster in the chapter "Register Cluster"

Labels are similar to AWS tags. For example, in AWS you can designate a role for an EC2 instance using tags like app=webserver or app=appserver. These tags help identify the role or purpose of the instance.

Labels in ArgoCD work in a similar way. You can assign labels to clusters to indicate their role, environment, or purpose. For instance, labeling a cluster with workload_webstore=true(indicating it can deploy the Webstore app) or environment=staging( indicating it should receive staging versions) allows tools like Argo CD ApplicationSet to target the right clusters dynamically based on these roles.

Let's look at a few examples of how to use labels with the Cluster generator.

Let's say there are 3 cluster objects - hub-cluster, spoke-staging and spoke-prod with different labels (key value pairs).

The following is a code snippet of an ApplicationSet. The cluster generator creates one application because one cluster label matches the criteria.

```
  .
  .
  generators:
  - clusters:
      selector:
        matchLabels:
          environment: hub
  .
  .
```

![applicationset](/static/images/argobasics/applicationset-controlplane.png)

The following generator creates 2 applications because 2 cluster labels match the criteria.

```
  generators:
  - clusters:
      selector:
        matchLabels:
          workloads: true
```

![applicationset](/static/images/argobasics/applicationset-workloads.png)

If you update the labels on a cluster, the ApplicationSet controller will **dynamically** generate new ArgoCD Applications or delete existing ones based on the updated label values.
